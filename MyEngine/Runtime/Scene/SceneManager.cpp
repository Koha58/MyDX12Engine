#include "Scene/SceneManager.h"
// 必要に応じて <string>, <memory>, <unordered_map> はヘッダ内で包含されている前提。
// ここでは実装の“意図”を後から見返しても分かるように詳細コメントを付与。

/*
===============================================================================
SceneManager.cpp
-------------------------------------------------------------------------------
役割：
  - 複数の Scene を名前付きで保持・切替する“薄い”管理クラス。
  - 実際の更新・描画は Scene 側が担当。ここでは「どの Scene をアクティブ
    とみなすか」の選択と、その呼び出しエントリ（Update）を提供する。

設計メモ：
  - 所有権：m_Scenes の値型は std::shared_ptr<Scene>。
    SceneManager はシーンの“共有所有者”の一人として保持する。
  - アクティブ参照：m_CurrentScene は weak_ptr。
    → 「アクティブであること」は Scene の寿命（shared_ptr カウント）とは独立。
      Scene が外部で破棄されても、ここは lock() が空になるだけで安全。
  - スレッドセーフではない：
      登録/切替/更新は同一スレッド（通常はメインスレッド）から呼ぶ想定。
  - 拡張ポイント：
      SwitchScene() で旧シーンの OnDisable、新シーンの OnEnable などを
      呼びたい場合は、ここにフックを追加する。

落とし穴：
  - RemoveScene() で消した後も m_CurrentScene が同名シーンを指す可能性。
    → GetActiveScene() は毎回 lock() で検証するため “使う側” は安全だが、
      論理的な一貫性を保つなら Remove 時にアクティブを無効化/切り替える処理を
      追加してもよい（プロジェクト方針に合わせる）。
===============================================================================
*/

// ============================================================================
// AddScene
// ----------------------------------------------------------------------------
// ・シーンを名前で登録/上書きする（同名なら差し替え）。
// ・登録時点でアクティブにはならない（切替は SwitchScene で行う）。
// ============================================================================
void SceneManager::AddScene(const std::string& name, std::shared_ptr<Scene> scene)
{
    // shared_ptr をそのまま保持：SceneManager も所有者になる
    m_Scenes[name] = std::move(scene);
}

// ============================================================================
// RemoveScene
// ----------------------------------------------------------------------------
// ・シーンを名前で削除（未登録名なら何もしない）。
// ・注意：m_CurrentScene がこのシーンを指している可能性がある。
//   → GetActiveScene() は毎回 lock() で検証するので使用側は安全。
//   → 論理的にアクティブを消したくない場合は、ここでフェイルさせる/別名へ
//      自動切替などのポリシーを追加する余地がある。
// ============================================================================
void SceneManager::RemoveScene(const std::string& name)
{
    m_Scenes.erase(name);
}

// ============================================================================
// SwitchScene
// ----------------------------------------------------------------------------
// ・アクティブシーンを名前で切り替える（未登録名なら無視）。
// ・現状は“参照の付け替えのみ”。旧シーンの OnDisable や新シーンの OnEnable、
//   リソース解放/ロードなどはプロジェクトの要件に応じてここに追加する。
// ============================================================================
void SceneManager::SwitchScene(const std::string& name)
{
    auto it = m_Scenes.find(name);
    if (it != m_Scenes.end())
    {
        // weak_ptr に差し替え（寿命は登録側の shared_ptr 群に依存）
        m_CurrentScene = it->second;
    }
    // else: 未登録 → 何もしない（ログを出したい場合はここで）
}

// ============================================================================
// GetActiveScene
// ----------------------------------------------------------------------------
// ・現在アクティブとみなしているシーンを shared_ptr で返す。
// ・weak_ptr を lock() して取得するため、既に破棄されていれば nullptr。
// ・呼び出し側は戻り値の有無を毎回チェックするのが前提。
// ============================================================================
std::shared_ptr<Scene> SceneManager::GetActiveScene() const
{
    return m_CurrentScene.lock(); // → 有効なら shared_ptr、無効なら nullptr
}

// ============================================================================
// Update
// ----------------------------------------------------------------------------
// ・アクティブシーンが有効なら、その Update を呼び出す。
// ・Scene が破棄済み/未設定なら何もしない（安全側）。
// ・描画（Render）はレンダリング側のフローで呼ぶ前提。ここでは論理更新のみ。
// ============================================================================
void SceneManager::Update(float deltaTime)
{
    if (auto activeScene = m_CurrentScene.lock())
    {
        activeScene->Update(deltaTime);
    }
    // else: アクティブなし/破棄済み → 何もしない
}
